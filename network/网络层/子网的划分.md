# 按照基本分类存在的问题

1. 地址空间利用率不高
    A类地址1000万台主机， B类地址6万多主机， C类只有254台主机
    这样的划分太死板， 不适合现实情况

2. 路由表非常庞大
    每一个网络地址就需要一个路由项目
    有更有效的方式， 将多个网络号聚合在一起， 主要是C类地址
    外部网络只需要知道一个 出口路由的地址 即一条路由项目

3. 地址使用不灵活
    接入网络前必须先分配地址


# 划分子网

将一类ip地址空间进行新的划分, 取主机号的 前n位作为子网字段, 与网络号共同组成 网络号

子网号对网络外部是透明的, 即外部网络不知道是否划分子网
外部网络会根据 网络号 先将数据转发到 对应的路由器
路由器内部再根据是否划分子网， 转发到子网的路由器上

网络号+主机号 => 网络号+子网号+主机号

通过子网掩码与地址按位 与 运算， 得到 子网号

规定， 子网号全0或是全1 都不能使用

路由表构成
目的网络 子网掩码  下一跳地址

## 修改后的转发算法
目的地址D
1. 同一子网内的直接交付
    D 与 当前网络的 子网掩码 与 运算, 若得到的子网络号与自己相同, 则直接交付
2. 有特定的路由， 将数据转发到特定路由
3. 逐一与路由表中的子网掩码按位 与 运算， 比较目的网络和结果是否相同， 如果相同， 则查表成功， 将数据转发到对应的路由器中去
4. 第三步还没有找到的话， 看是否有默认路由， 有的话 传给默认路由
5. 没有默认路由则 转发分组报错


以上在基础分类的基础上， 进行子网的划分， 相当于将一个大的网络， 分割成多个小的网络


# CIDR 无分类编址方案

脱离基本的分类方案, 网络号可以为任意长度, 不再受 A, B,C类已有网络号的约束
好处是更加有效地利用ipv4地址空间, 可以根据需要调整地址块的大小
在基本分类中， 只能按照A,B,C的分配， 利用率太低, 也不灵活

## 地址块
    ip/地址掩码长度
    128.14.35.7/20, 该ip的前20位都是 网络号, 后12位为 主机号

## 地址空间
    地址块中的最小地址和最大地址组成的范围

# 地址空间内的子网划分
    同基本的子网划分, 再占用一定位数的 主机字段, 划分子网, 增加地址掩码的长度即可

    加入需要 n 个主机，则申请 ceil(log2(n)) 位 做主机号 其他全部当做子网字段
    比如 256个主机
    ip/24 , 后8位做主机号

# 超网与路由聚合
    我们知道, 两个ip地址， 使用同一个地址掩码计算的结果相同， 则同属一个网络
    所以, 地址掩码长度越短， 包含的 地址个数就越多。 可以在此基础上 增加地址掩码长度， 划分子网
    反之， 不同子网组成一个超网.

    超网之间的通信， 处于超网之间的路由器 只需要维护各个超网之间的 路由信息， 降低了压力
    转发给维护该超网的路由器， 再根据内部 子网的划分进行转发。 也分清了职责

路由表的构成
    网络前缀 地址掩码 下一跳地址

    在匹配地址的时候， 可能会出现多个匹配的情况， 即子网内的地址都会匹配超网的网络前缀，
    需要选择具有最长网络前缀的路由

查表算法
    如果逐一查询, 找到最长匹配的网络前缀, 代价太高了.
    查找次数太多, 假设需要查找的地址在路由表中不存在， 到最后需要找到默认路由，
    需要更优秀的查询方式减少 查询次数, 即以最少的次数查出


将网络信息建立一棵 线索二叉树
根据目的地址， 从根节点开始逐一向下查询， 当无法匹配，则认为不存在

通过向下递进， 能匹配到的叶节点则是最大的 网络前缀
