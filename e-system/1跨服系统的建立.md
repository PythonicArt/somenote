# 登录节点与逻辑节点的连接

登录节点的组成

## 网络模块
application -> network
建立一棵监控树 network_sup, 主进程侦听tcp, 通过 ListenSock 建立子进程 network_accept, 进行连接的响应

network_accept
gen_server, 负责连接的响应和管理
1. 管理连接的数量
2. 连接的分配
```erlang
accept() ->
    case prim_inet:async_accept(LSock, -1) of
        {ok, Ref} ->
            {noreply, Stat#state{ref = Ref}};
        Error ->
            {stop, Error, State}
    end.

handle_info({inet_async, LSock, Ref, {ok, Sock}}, State = #state{sock = LSock, ref = Ref, cur = Cur}) ->
    true = inet_db:register_socket(Sock, inet_tcp),
    % 通过game_sup启动一个子进程, 把连接分配给该进程
    case supervisor:start_child(game_sup, []) of
        {ok, Child} ->
            _MRef = erlang:monitor(prcess, Child),
            true = erlang:unlink(Child)
            State2=
            case gen_tcp:controlling_process(Child, Sock) of
                ok ->
                    game_server:active(Child, Sock),
                    State#state{cur = Cur + 1};
                {error, Reason} ->
                    gen_tcp:close(Sock),
                    State
            end,
            accept(State2);
        Error ->
            gen_tcp:close(Sock)
            accept()
    end.

game_sup 监控树的ChildSpec
GameServer = {game_server, {game_server, start_link, []}, temporary, 2000, worker, [game_server]}
{ok, {{simple_one_for_one, 10, 10}, [GameServer]}}

game_server 处理来自连接的消息, 一个逻辑节点的连接就对应一个 game_server
约定数据协议
    前2字节：数据包长度Len
    根据Len 取出实际的数据包

1. 连接的验证
    通过两端约定的token 和节点信息数据(id + time) 生成md5-2 与节点传过来的 md5-1比较， 相同则通过

2. 节点注册
    维护一个列表 array of  #serv_online{id = SId, pid = Pid, ref = MRef}

3. 设置state
    将节点信息(Type, Sid, Plat, Sock) 存于state, 开启异步接收消息(prim_inet:async_recv)



```
