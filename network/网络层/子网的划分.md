按照基本分类存在的问题

1. 地址空间利用率不高
    A类地址1000万台主机， B类地址6万多主机， C类只有254台主机
    这样的划分太死板， 不适合现实情况

2. 路由表非常庞大
    每一个网络地址就需要一个路由项目
    有更有效的方式， 将多个网络号聚合在一起， 主要是C类地址
    外部网络只需要知道一个 出口路由的地址 即一条路由项目

3. 地址使用不灵活
    接入网络前必须先分配地址


划分子网
将一类ip地址空间进行新的划分， 取主机号的 前n位作为子网字段, 与网络号共同组成 网络号

网络号 (主机号)

网络号 (子网号+主机号)

通过子网掩码与地址按位 与 运算， 得到 子网号

规定， 子网号全0或是全1 都不能使用

路由表构成
目的网络 子网掩码  下一跳地址

转发算法
目的地址D
1. 同一子网内的直接交付
    D 与 当前网络的 子网掩码 与 运算, 若得到的子网络号与自己相同, 则直接交付
2. 有特定的路由， 将数据转发到特定路由
3. 逐一与路由表中的子网掩码按位 与 运算， 比较目的网络和结果是否相同， 如果相同， 则查表成功， 将数据转发到对应的路由器中去
4. 第三步还没有找到的话， 看是否有默认路由， 有的话 传给默认路由
5. 没有默认路由则 转发分组报错


以上在基础分类的基础上， 进行子网的划分， 相当于将一个大的网络， 分割成多个小的网络


CIDR 无分类编址方案

脱离基本的分类方案， 网络号可以为任意长度
好处是更加有效地利用ipv4地址空间, 可以根据需要调整地址块的大小
在基本分类中， 只能按照A,B,C的分配， 利用率太低, 也不灵活

地址块
    ip/地址掩码

地址空间
    地址块中的最小地址和最大地址组成的范围

地址空间内的子网划分
    同基本的子网划分, 再占用一定位数的 主机位, 划分子网

    加入需要 n 个主机，则申请 [log2(n)] 位 做主机号 其他全部当做子网字段
    比如 256个主机
    ip/24 , 后8位做主机号


路由表的构成
    网络前缀 地址掩码 下一跳地址

    在匹配地址的时候， 可能会出现多个匹配的情况， 即子网内的地址都会匹配超网的网络前缀，
    需要选择具有最长网络前缀的路由

查表算法
    如果逐一查询, 找到最长匹配的网络前缀, 代价太高了.
    查找次数太多, 假设需要查找的地址在路由表中不存在， 到最后需要找到默认路由，
    需要更优秀的查询方式减少 查询次数, 即以最少的次数查出


将网络信息建立一棵 线索二叉树
根据目的地址， 从根节点开始逐一向下查询， 当无法匹配，则认为不存在

通过向下递进， 能匹配到的叶节点则是最大的 网络前缀
