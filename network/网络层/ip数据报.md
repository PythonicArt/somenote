# ip层的数据报格式

头部+数据部分

头部包含 网络层算法, 功能和路由需要的所有数据

长度
地址
分片
协议

头部
    第一行, 数据信息
        版本信息(4) 首部长度(4) 区分服务(8) 总长度(16)，
    第二行, 分片信息
        identification(16) flag(3) 片偏移(13)
    第三行, 协议信息
        生存时间(8) 协议(8) 首部校验和(16)
    第四,五行, 地址信息
        源地址 (32)
        目的地址 (32)

    其他行
        其他选项, 用于特殊功能(排错, 安全), 每一行不足32位的用0补齐一行
        由于头部长度的限制, 最多10行

    头部的长度范围
        前五行是固定的字段， 也是一个ip数据报成立的最短的数据报头，
        最小 即 5*4=20字节
        从首部长度 4位可以看出， 首部最长 1111 = 15，其单位是4字节,  即15*4=60字节

## 第一行, 数据信息
版本(4位)
    0100 ipv4
    0110 ipv6

首部长度(4位)
    0101 最小5, 单位是4字节, 总共20字节
    1111 最大15, 总共60字节

区分服务(8位)， 不使用， 可理解为占位

总长度
    最大2^16-1=65535， 单位为字节， 即65535字节

    由于以太网的MTU 为 1500字节， ip数据报大于这个值就需要切片
    总长度越大， 传输效率越高， 因为数据的占比会更大
    数据更短, 更有利于路由器转发, 不需要太多的缓存

    综合考虑，每个主机都需要能处理至少576的数据报
        60(头部)+512(数据)+4(盈余) = 576

    当超过这个值， 可以根据实际情况进行分片

## 第二行, 分片信息
identification(16位)
    数据报标识， 每一个数据报都具有一个标识号， 同一数据报的不同分片的具有相同的标识

flag(3位)
    DF MF 0
    DF don't flagment, =1 时标识不能分片 =0时 表示 允许分片
    MF more flagment =1 时有更多的分片, =0时 表示 没有更多的分片， 也就是最后一个分片
        只有DF=0时 MF才有意义
    0 最后一位不使用
    1X0 => 不允许分片
    010 => 允许分片, 且属于中间位置
    000 => 允许分片, 当前为最后一个分片

片偏移(13位)
    相对于数据报字段的起点, 该分片从何处开始.
    以8字节为单位

    将总长度3820， 头部为20的数据报进行分片, 每个分片最大 1420

    每个分片数据最大 1400
    所以分片个数为 ceil(3800 / 1400) = 3
    1 0-1399 => 0
    2 1400-2799 => 1400 / 8 = 175
    3 2800-3799 => 2800 / 8 = 350

    合并时, 根据 identification 找到同一个分片， 将偏偏已进行排序， 从小到大进行拼装.得到完整的数据


## 第三行, 协议信息
生存时间(8)
    每经过一个路由器， 该值减一， 当路由器收到为1， 即到此为0的数据报， 表示已经超过限制， 直接丢弃
    最大值 2^8-1=255

协议(8)
    表明数据字段中采用怎样的协议, 上层通过这个字段选择对应的数据解析方式， 明确如何处理数据
    或是数据格式属于哪一个协议, 如  ICMP， IGMP, TCP, UDP

首部校验和(16)
    只检验首部， 不检查数据
    检验不通过的将数据丢弃
