用于节点间不同进程的数据通信

## 端口
    不同操作系统的 进程标识是不统一的。 如果使用进程标识来确定进程， 则需要记录操作系统的信息， 这样就与操作系统相关
    可以建立一个统一的编号机制， 给不同的操作系统使用， 操作系统将一个编号与进程绑定起来， 这样网络层面只需要传输这个编号， 就可以完成进程间的通信
    这样的编号叫做端口.
    在网络层面, 可以忽略进程的存在， 直接理解为端口之间的通信.
    端口号会加入到传输控制层协议的报文里， 网络系统根据端口号找到对应的进程
    16位 1-65535
        常见端口：1-1023， 为某些标准服务使用, telnet 使用23， ftp使用 20,21

        临时端口： 1024-65535， 由具体的网络应用使用

        为了避免冲突， 即同一节点上不同的进程使用相同的端口， 需要提供一个端口管理服务， 拒绝进程申请已使用的端口或是保证不分配已使用的端口

## socket
    网络编程的一组接口,  一个socket是一种特殊类型的文件句柄, 被一个进程使用，向操作系统请求网络服务
    每一种编程语言的socket编程部分都是调用操作系统的这一服务实现的

    地址
        <protocol, local-address, local-port>
        <tcp, 192.168.14.234, 8080>

    会话
        两个进程之间的通信连接

    连接
        <protocol, local-address, local-port, foreign-address, foreign-port>

    全双工字节流服务
        有两个独立的数据流， 分别由连接的两端控制, 所以连接的两端可以同时发送和接收消息， 即同时使用网络

# udp
特点
    简单地不同端口之间的通信, 不提供可靠性， 流量控制和错误恢复
    需要上层实现这些机制
    不分片, 应用层发来多少数据就交付多少。直接拼上首部传给ip层

报文结构
    源端口(16位) 目标端口(16位)
    长度(16位) 校验和(16位)
    DATA

长度字段  
    以字节为单位, 包含报头的长度(首行32位第二行32位 = 8字节)
    最大65535, 所以一个数据报内容最大 65535-8=65527 字节

应用
    DNS

# tcp
    特点
        提供可靠性， 流量控制和错误恢复机制， 保证不同端口之间基于连接的正确通信

        基于连接：
            连接时一个逻辑的概念，在通信双方之间会维护一些状态， 比如sockets，序列号(切片), 窗口大小等, 这些状态是一次通信所存在的数据集合， 这个集合统称为连接
            这些状态在udp是没有的， udp只管交互， 不管状态

        流数据传输：
            网络应用无需考虑数据的切片，切片与合并， 这些都交给tcp协议来完成
            切片和编号
                一个数据报有大小的限制， 将一个完整的数据 切分成不同的片， 并给予编号， 通过网络发送
                接收方收到数据， 再根据编号对数据进行合并， 保证数据的顺序性

        可靠性：
            保证数据从发送方完整地, 正确地到达接收方

            准确性保证
                约定一个校验和算法, 发送方和接收方两边根据同样的算法 针对数据计算校验和， 如果相同， 则认为数据正确一致 没有被修改

            超时重发
                对于发出的数据， 发送方收到接收方的确认后， 认为该报正确发送.
                当一个数据发出， 在一定时间内没有收到回复 则认为接收方没有收到， 需要重新发送

            流量控制：
                通信的接收方会在回复确认包时将自身的接收能力附加到数据报里，发送方以此建立一个可变大小的逻辑空间，
                这个空间的大小就是
                在接收方所能承受的能力范围内 最大的数据量的大小, 以字节为单位
                同时, 会根据网络的通畅程度再维护一个逻辑空间, 这个空间的大小代表着当前网络状态下所能承受的数据量的最大值

                结合两者, 保证在不影响网络通畅和接收方接受能力的前提下, 发送数据

    应用
        需要可靠网络服务 并且自身不需实现正确网络传输的网络应用
        HTTP

    报文结构
        1: 源端口 目的端口
        2: 发送序列号(32位)
        3: 确认序列号(32位)
        4: 数据偏移(4位) 保留字段(6位) 状态位(6位) 窗口(16位)
        5: 校验和(16位) 紧急指针字段
        6-n : 选项字段-补位字段，可以包含数行， 也就是这个决定了报头的长度是变化的, 当选项数据放不下一行时， 补0

        关于序列号与数据量的大小
            由于序列号时32位， 且以字节为单位的。 则一次只能对2^32次方=4GB大小的数据进行编号
            大于4G的量就会出现重复编号, 中间会传一次rst包, 然后开始传送新的数据

        数据偏移
            报头的长度大小, 也是具体数据从哪里开始, 以32位, 4字节为单位，可以理解为报头有几行, 有多少个4字节
            由于是 4位，最大值 1111 = 15， 说明报头最大的长度 15*4=60字节

        保留位
            全是0 以后使用

        窗口
            ACK 置1时生效, 指明一个以字节为单位的长度, 表示从 确认序列号开始，接受者希望接受的数据量的大小

        状态位
            URG ACK PSH RST SYN FIN
            这些状态表明这个状态所映射的字段的数据是否生效, 或是当前报文具有某个特殊的性质, 比如 SYN字段为1， 发送序列号是生效的， 也表明这是个发送方的数据报
            URG 紧急指针字段
            ACK 确认序列号字段
            PSH PUSH FUNCTION ?
            RST 重置连接
            SYN 同步序列号字段, 建立连接时置1
            FIN 没有额外数据，连接即将结束, 关闭连接时置1

        校验和
            整个报头和数据的校验和， 在计算的时候， 该字段为0

        紧急指针字段

        选项字段
            两种格式
            1. 一个字节， 只包含 选项编号，即选项类型
                -- 0 选项结束
                -- 1 无操作

            2. option(1字节，8位) length (1字节, 8位) option-data (length -2)
                -- 2 4 max.seg size(2字节 16位)  -> 三次握手时接收方发送的 syn包中 如果加上这个选项， 代表 接收方期待的**最大的报文的长度**, 如果没有使用， 表示可接受任意长度

                -- 3 3 shift.cnt(1字节 8位) -> 在握手时传输， 将16位位单位的窗口大小 调整为 32位的窗口大小

                -- 5 length data(array of 序列号) -> 接收方回复时一些序列号放入该选项中， 提醒发送方重发, 可以是当前丢失的包， 也可以是指定的包。 如果需要使用这个字段， 需要考虑总大小, 只放部分序列号

                -- 8 10 发送时间戳(4字节 32位)  回复时间戳(4字节 32位)

    特性实现方式
        逐一确认再发送的方式的改进
            如果每一个包都需要逐一确认， 则浪费带宽
            0. 批量发送
            1. 当发送方 收到 序列号为 n 的确认包， 发送方则认为 n 及之前的所有包都被接收方收到, 此时n及之前所有的包 都无需再发送
            2. 到接收方收到1-n 的包， 而中间的 i 没有收到， 此时i 之后的所有包的 确认序列号都是 i-1， 而不是自己的编号

        编号
            tcp提供字节流连接， 需要传输的数据的每一个字节都有一个自己的编号

            窗口大小是以 字节为单位的， 不是以数据包的数量为单位
            窗口大小是由接收方在连接建立时决定的， 每一个确认包都会附加一个窗口的长度， 代表当下准备处理的数据的长度， 同样, 以字节为单位

            任何时候， 窗口就是一个数据范围，
                在这个范围之前的, 代表成功传输并且得到确认的序列号
                在这个范围之内的， 代表已经发送而没有得到确认， 或是可以发送还未发送的序列号。 当这个范围内的所有数据都发送出去， 则发送方停止发送
                在这个范围之后的， 代表当下还不能发送的

                当一个序列号seq得到确认, 窗口的初始点变为 seq+1

            假设一个包初始字段的为 seq, 包长为 len, 窗口大小为 size, 此时 可发送范围则为  seq -> seq + size - 1
                acknowledgments number 回复的为 seq+len， 表示接收方期望 seq+len的序列号的数据,  也代表seq+len-1及之前的数据都得到确认

                当收到 seq + len, 窗口范围变为 seq + len -> seq + len + size - 1, 称此过程为窗口的滑动

                假设 接收方 没有收到 seq + len 的包,  先收到了 seq + 2*len 的包, 回复的还是  seq+len， 代表接收方期望接受
                发送方收到后， 即使没有超时， 马上开始重传

                出现 一个包没有收到， 而之后的包收到的情况时， 之后的所有包的ack都是最开始没有收到的那个包的序列号

                当发送方收到多个同样的确认序列号时， 明确地表示这个包丢失了. 而对于之后的包是否正确收到， 发送方也是无法判断的， 因为ack只有一个序列号， 而没有
                额外地表明 这是由哪一个实际的包发起的ack

            超时时间的确定
                不同的网络状态决定了延时的大小， 需要实时地根据网络状态决定 超时的时间
                可以实时地统计 一个包从发送到被确认所流逝的时间， 根据多个包的时间取平均值来得到


        三次握手
            被连接的一方监听一个端口, 连接的发起方发起连接。
            clinet                                      server
                    1:-> SYN=1, seq=999
                    SYN=1,ACK=1 seq=4999, ack=1000 <-:2
                    3:-> ACK=1, seq=1000, ack=5000

            三次握手其实就是发三次包
            前两次需要 SYN=1表明在建立连接
            后面两个包分别是前面包的确认 ACK=1
            第一个包 连接发起方建立一个  seq, 由接收方在第二个包确认
            第二个包 接收方同时 建立一个 seq , 由发起方在第三个包确认

            第三个包其实已经可以带真实的数据了

            SYN攻击：
                在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。
                SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，
                由于源地址是不存在的,因此，Server需要不断重发直至超时, 这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。

        四次挥手
            由于是全双工的数据流， 断开连接需要将两条数据流都要断掉才算真正地断掉
            也就是说，双方都需要发起 断开连接的一个包， 并由对方确认

            clinet                       server
                    1:-> FIN=1, seq=999
                    ACK=1 ack=1000 <-:2
                    FIN=1 seq=4999 <-:3
                    4:-> ACK=1, ack=5000

        拥塞控制算法
            慢启动 与 拥塞避免
                发送窗口是接收方在回复ack包时决定的。 如果一开始就以这个窗口的大小发送数据包， 由于网络的复杂性， 有可能在发送的时候线路并不通常， 导致中间的路由器丢包
                一旦丢包发生， 网络传输效率就降低。
                未通过慢启动的算法避免. 增加拥塞窗口， 即发送方由发送窗口和拥塞窗口共同决定, 即同时发送的数据量 不超过 拥塞窗口和发送窗口的大小
                拥塞窗口是发送方的流量控制， 发送窗口是接受方的流量控制
                初始从 1个数据包开始, 当收到数据包的回复， 拥塞窗口就自增1. 可以看到，这是以2位指数增长的函数

                当增长的一定的规模， 网络开始拥堵， 进入拥塞避免状态

                1. 超时发生
                2. 收到重复的ack包
                以上两种情况都表明着需要重传数据， 也意味着网络开始不那么通畅, 需要降低发送速度

                增加一个慢启动阈值, 初始化为65535字节.
                初始, 从慢启动开始

                当拥塞窗口大小 小于或等于 阈值，为慢启动状态， 否则为 拥塞控制状态
                慢启动时窗口 成倍增加， 指数增长， 拥塞控制时 窗口线性增加, 每次增加  segsize*segsize / cwnd

                当拥塞发生时,
                当前阈值立即变为当前窗口的一半.   
                如果是超时触发的， 会额外将拥塞窗口设置为1, 此时重新进入慢启动
                从这可以看出， 超时意味着网络的极不稳定

                快速重传 与 快速恢复
                当发送方收到多个相同的ack时， 意味着这个包已经丢失， 即使没有超时， 马上开始重传

                如果是重复的ack,
                当收到第三个重复的ack， 慢启动阈值减半, 重传丢失的包, 将 当前拥塞窗口设置为 ssthresh+3*segsize, 这个值代表了一个丢失的包，和两个已经接受被
                接收方缓存的包, 此时由于窗口减小了， 是无法发送新的包的

                如果又出现重复ack来到， 窗口值增加 segsize, 这个值是丢失的包的大小。 此时如果可以发新的数据， 就发送。
                这里没有完全打住， 也有一个小小的增加

                当新的ack到来， 将窗口大小设置为 阈值大小, 这个ack代表着之前丢失的包已经收到, 而且ack及以前的包都已经收到
                此时是拥塞避免状态， 因为窗口大小已经减半
