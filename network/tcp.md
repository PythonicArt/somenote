用于节点间不同进程的数据通信

端口
    不同操作系统的 进程标识是不统一的。 如果使用进程标识来确定进程， 则需要记录操作系统的信息， 这样就与操作系统相关
    可以建立一个统一的编号机制， 给不同的操作系统使用， 操作系统将一个编号与进程绑定起来， 这样网络层面只需要传输这个编号， 就可以完成进程间的通信
    这样的编号叫做端口.
    在网络层面, 可以忽略进程的存在， 直接理解为端口之间的通信.
    端口号会加入到传输控制层协议的报文里， 网络系统根据端口号找到对应的进程
    16位 1-65535
        常见端口：1-1023， 为某些标准服务使用, telnet 使用23， ftp使用 20,21

        临时端口： 1024-65535， 由具体的网络应用使用

        为了避免冲突， 即同一节点上不同的进程使用相同的端口， 需要提供一个端口管理服务， 拒绝进程申请已使用的端口或是保证不分配已使用的端口

socket
    网络编程的一组接口,  一个socket是一种特殊类型的文件句柄, 被一个进程使用，向操作系统请求网络服务
    每一种编程语言的socket编程部分都是调用操作系统的这一服务实现的

    地址
        <protocol, local-address, local-port>
        <tcp, 192.168.14.234, 8080>

    会话
        两个进程之间的通信连接

    连接
        <protocol, local-address, local-port, foreign-address, foreign-port>

    全双工字节流服务
        连接的两端可以同时发送和接收消息， 即同时使用网络

udp
    特点
        简单地不同端口之间的通信, 不提供可靠性， 流量控制和错误恢复
        需要上层实现这些机制

    报文结构
        源端口 目标端口
        长度(16位) 校验和(16位)
        DATA

    长度字段  
        以字节为单位, 包含报头的长度(首行32位第二行32位 = 8字节)
        最大65536，所以内容最大 65535-8=65527 字节

    应用
        DNS

tcp
    特点
        提供可靠性， 流量控制和错误恢复机制， 保证不同端口之间基于连接的正确通信

        基于连接：
            连接时一个逻辑的概念，在通信双方之间会维护一些状态， 比如sockets，序列号(切片), 窗口大小等, 这些状态是一次通信所存在的数据集合， 这个集合统称为连接

        流数据传输：
            网络应用无需考虑数据的切片，编号和接收方的切片的合并， 这些都交给tcp协议来完成
            切片和编号
                一个数据报有大小的限制， 将一个完整的数据 切分成不同的片， 并给予编号， 通过网络发送
                接收方收到数据， 再根据编号对数据进行合并， 保证数据的顺序性

        可靠性：
            保证数据从发送方完整地， 正确地到达接收方

            约定一个校验和算法， 发送方和接收方两边根据同样的算法 针对数据计算校验和， 如果相同， 则认为数据正确一致 没有被修改

            超时重发
                对于发出的数据， 发送方以收到接收方的确认为准，当一个数据发出， 在一定时间内没有收到回复
                则认为接收方没有收到， 则自动重新发送

        流量控制：
            通信的接收方会在回复确认包时将自身的接收能力附加到数据报里，发送方以此建立一个可变大小的逻辑空间， 这个空间的大小就是一次性
            在发送方说能承受的能力范围内 最大的数据量的大小， 以字节为单位
            同时， 会根据网络的通畅程度再维护一个逻辑空间， 这个空间的大小代表着当前网络状态下所能承受的数据量的最大值

            结合两者， 保证在不影响网络通畅和接收方接受能力的前提下， 发送数据

    应用
        需要可靠网络服务 并且自身不需实现正确网络传输的网络应用
        HTTP

    报文结构
        1:源端口 目的端口
        2:发送序列号(32位)
        3:确认序列号(32位)
        4: 数据偏移() 保留字段(6位) 状态位(6位) 窗口()
        5: 校验和(16位) 紧急指针字段
        6-n : 选项字段-补位字段，可以包含数行， 也就是这个决定了报头的长度是变化的, 当选项数据放不下一行时， 补0

        数据偏移
            报头的长度大小, 也是具体数据从哪里开始, 以32位, 4字节为单位，可以理解为报头有几行, 有多少个4字节

        状态位
            URG ACK PSH RST SYN FIN
            这些状态表明这个状态所映射的字段的数据是否生效, 或是当前报文具有某个特殊的性质, 比如 SYN字段为1， 发送序列号是生效的， 也表明这是个发送方的数据报
            URG 紧急指针字段
            ACK 确认序列号字段
            PSH PUSH FUNCTION ?
            RST 重置连接
            SYN 发送序列号字段
            FIN 没有额外数据，连接即将结束

        校验和
            整个报头和数据的校验和， 在计算的时候， 该字段为0

        选项字段
            两种格式
            1. 一个字节， 包含 选项编号，即选项类型
            2. option(1字节，8位) length (1字节, 8位) option-data (length -2)
                -- 2 4 max.seg size(2字节 16位)  -> 三次握手时接收方发送的 syn包中 如果加上这个选项， 代表 接收方期待的最大的报文的长度
                -- 3 3 shift.cnt(1字节 8位) -> 在握手时传输， 将16位位单位的窗口大小 调整为 32位的窗口大小
                -- 5 length data(array of 序列号) -> 接收方回复时一些序列号放入该选项中， 提醒发送方重发, 可以是当前丢失的包， 也可以是指定的包。 如果需要使用这个字段， 需要减小字段大小, 只放部分序列号
                -- 8 10 发送时间戳(4字节 32位)  回复时间戳(4字节 32位)

    特性实现方式
        三次握手
        四次挥手
        拥塞控制算法
